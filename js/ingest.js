// DealUpdates - CSV ingest pipeline
// Shared by app.js (browser) and generate-golden.js (Node.js)

(function(exports) {
    'use strict';

    // ==================== Domain dependency ====================
    const DealDomain = typeof require !== 'undefined'
        ? require('./domain.js')
        : window.DealDomain;

    const { parseACV, parseDate, calculateDaysSince, getUrgencyLevel,
            calculateDaysUntilClosing, getClosingStatus, makeDealKey,
            buildNotesCanonical, sha256Hex } = DealDomain;

    // ==================== Configuration ====================
    const COLUMN_MAPPINGS = {
        'Deal Owner': 'dealOwner',
        'Deal Name': 'dealName',
        'Stage': 'stage',
        'Annual Contract Value': 'acv',
        'Closing Date': 'closingDate',
        'Modified Time (Notes)': 'modifiedDate',
        'Note Content': 'noteContent',
        'Description': 'description'
    };

    // ==================== Helpers ====================
    function stripHTML(html) {
        if (!html) return '';
        if (typeof document !== 'undefined') {
            const temp = document.createElement('div');
            temp.innerHTML = html;
            return temp.textContent || temp.innerText || '';
        }
        return html.replace(/<[^>]*>/g, '');
    }

    function formatCurrency(value) {
        return new Intl.NumberFormat('en-CA', {
            style: 'currency',
            currency: 'CAD',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
        }).format(value);
    }

    // ==================== CSV Parsing ====================
    function parseCSV(text) {
        // Remove BOM if present
        if (text.charCodeAt(0) === 0xFEFF) {
            text = text.slice(1);
        }

        // Parse all rows handling multiline quoted fields
        const allRows = parseCSVText(text);

        console.log('Total rows parsed:', allRows.length);
        console.log('First 3 rows:', allRows.slice(0, 3));

        if (allRows.length === 0) {
            throw new Error('No data found in CSV file.');
        }

        // Find header row and extract "Generated by" date
        let headerRowIndex = -1;
        let headers = [];
        let generatedDate = null;

        for (let i = 0; i < Math.min(allRows.length, 20); i++) {
            const row = allRows[i];

            // Check for "Generated by" row before finding header
            if (headerRowIndex === -1) {
                const joinedRow = row.join(' ').trim();
                if (/generated\s+by/i.test(joinedRow)) {
                    // Try to extract a date from this row
                    // Match patterns: 2/10/2026, 2026-02-10, Feb 10 2026, February 10, 2026, etc.
                    const datePatterns = [
                        /(\d{4}[-\/]\d{1,2}[-\/]\d{1,2})/,
                        /(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4})/,
                        /(\w+\s+\d{1,2},?\s+\d{4})/,
                        /(\d{1,2}\s+\w+\s+\d{4})/
                    ];
                    for (const pattern of datePatterns) {
                        const match = joinedRow.match(pattern);
                        if (match) {
                            const parsed = new Date(match[1]);
                            if (!isNaN(parsed.getTime())) {
                                generatedDate = parsed;
                                console.log('Extracted "Generated by" date:', generatedDate);
                                break;
                            }
                        }
                    }
                    if (!generatedDate) {
                        console.warn('Found "Generated by" row but could not parse date:', joinedRow);
                    }
                }
            }

            if (row.includes('Deal Owner') && row.includes('Deal Name')) {
                headerRowIndex = i;
                headers = row;
                console.log('Found header at row', i, ':', headers);
                break;
            }
        }

        if (headerRowIndex === -1) {
            throw new Error('Could not find header row. Looking for "Deal Owner" and "Deal Name" columns.');
        }

        const expectedColumns = headers.length;
        console.log('Expected columns:', expectedColumns);

        // Convert data rows to objects
        const rows = [];
        for (let i = headerRowIndex + 1; i < allRows.length; i++) {
            const values = allRows[i];

            // Skip completely empty rows
            if (values.length === 0 || (values.length === 1 && !values[0])) continue;

            // Log rows with unexpected column counts
            if (values.length !== expectedColumns) {
                console.log('Row', i, 'has', values.length, 'columns (expected', expectedColumns, '):', values[0]);
            }

            // Convert to object
            const row = {};
            headers.forEach((header, index) => {
                row[header] = values[index] || '';
            });
            rows.push(row);
        }

        console.log('Total data rows:', rows.length);
        return { rows, generatedDate };
    }

    // Parse entire CSV text, properly handling multiline quoted fields
    function parseCSVText(text) {
        const rows = [];
        let currentRow = [];
        let currentField = '';
        let inQuotes = false;

        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const nextChar = text[i + 1];

            if (inQuotes) {
                // Inside a quoted field
                if (char === '"') {
                    if (nextChar === '"') {
                        // Escaped quote ("") - add single quote and skip next
                        currentField += '"';
                        i++;
                    } else {
                        // End of quoted field
                        inQuotes = false;
                    }
                } else {
                    // Any character inside quotes (including newlines) is part of the field
                    currentField += char;
                }
            } else {
                // Outside quotes
                if (char === '"') {
                    // Start of quoted field
                    inQuotes = true;
                } else if (char === ',') {
                    // Field separator - end current field
                    currentRow.push(currentField);
                    currentField = '';
                } else if (char === '\r') {
                    // Carriage return - check for Windows line ending
                    if (nextChar === '\n') {
                        i++; // Skip the \n
                    }
                    // End of row
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                } else if (char === '\n') {
                    // Unix line ending - end of row
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                } else {
                    // Regular character
                    currentField += char;
                }
            }
        }

        // Don't forget the last field and row
        if (currentField || currentRow.length > 0) {
            currentRow.push(currentField);
            rows.push(currentRow);
        }

        return rows;
    }

    // ==================== Data Processing ====================
    function processRow(row) {
        const deal = {};

        // Map columns
        for (const [csvCol, internalField] of Object.entries(COLUMN_MAPPINGS)) {
            deal[internalField] = row[csvCol] || '';
        }

        // Parse ACV - only keep CAD values
        const acvResult = parseACV(deal.acv);
        if (!acvResult.isCAD) {
            return null; // Skip non-CAD values
        }
        deal.acv = acvResult.value;
        deal.acvFormatted = formatCurrency(acvResult.value);

        // Parse and format dates
        deal.closingDate = parseDate(deal.closingDate);
        deal.modifiedDate = parseDate(deal.modifiedDate);

        // Calculate days since
        deal.daysSince = calculateDaysSince(deal.modifiedDate);
        deal.urgency = getUrgencyLevel(deal.daysSince);

        // Closing date awareness
        deal.daysUntilClosing = calculateDaysUntilClosing(deal.closingDate);
        deal.closingStatus = getClosingStatus(deal.daysUntilClosing);

        // Strip HTML from notes
        deal.noteContent = stripHTML(deal.noteContent);

        // Canonical identity key
        deal.dealKey = makeDealKey(deal.dealName, deal.dealOwner);

        return deal;
    }

    function validateRow(deal) {
        if (!deal) return false;

        // Check Deal Owner format - should be a name, not a sentence
        const owner = deal.dealOwner || '';
        if (!owner || owner.length > 100 || owner.split(' ').length > 5) {
            return false;
        }

        // Check Deal Name exists
        if (!deal.dealName || deal.dealName.trim().length === 0) {
            return false;
        }

        return true;
    }

    function generateFallbackSummary(notes) {
        // Deduplicate notes
        const unique = [...new Set(notes)];
        if (unique.length === 0) return '';

        // Extract first sentence from each unique note
        const sentences = unique.map(note => {
            const match = note.match(/^(.+?[.!?])\s/);
            if (match && match[1].length <= 150) {
                return match[1];
            }
            return note.length > 150 ? note.slice(0, 147) + '...' : note;
        });

        // Join and cap at 500 characters
        let summary = sentences.join(' | ');
        if (summary.length > 500) {
            summary = summary.slice(0, 497) + '...';
        }
        return summary;
    }

    async function deduplicateDeals(deals, existingDeals = [], generateAISummaries = async () => null) {
        const dealMap = new Map();
        const notesMap = new Map();

        for (const deal of deals) {
            const key = deal.dealKey;
            const existing = dealMap.get(key);

            // Collect all notes for this deal
            if (!notesMap.has(key)) {
                notesMap.set(key, []);
            }
            if (deal.noteContent && deal.noteContent.trim()) {
                notesMap.get(key).push(deal.noteContent.trim());
            }

            if (!existing) {
                dealMap.set(key, deal);
            } else {
                // Keep the one with newer modified date
                if (deal.modifiedDate && existing.modifiedDate) {
                    if (deal.modifiedDate > existing.modifiedDate) {
                        dealMap.set(key, deal);
                    }
                } else if (deal.modifiedDate) {
                    dealMap.set(key, deal);
                }
            }
        }

        const result = Array.from(dealMap.values());

        // Build canonical notes and hash for each deal (before summary reuse check)
        for (const deal of result) {
            const rawNotes = notesMap.get(deal.dealKey) || [];
            const { canonical, count } = buildNotesCanonical(rawNotes);
            deal.notesCanonical = canonical;
            deal.notesCount = count;
            deal.notesHash = await sha256Hex(canonical);
        }

        // Build lookup of existing deal data by key
        const oldDealMap = new Map();
        for (const old of existingDeals) {
            oldDealMap.set(old.dealKey || makeDealKey(old.dealName, old.dealOwner), old);
        }

        // Determine which deals need new AI summaries (hash-based reuse)
        const dealsNeedingSummary = [];
        let cacheHits = 0;
        for (const deal of result) {
            const oldDeal = oldDealMap.get(deal.dealKey);
            const oldSummary = oldDeal?.notesSummary || '';
            const oldHash = oldDeal?.summaryHash || '';

            if (oldSummary && oldHash && oldHash === deal.notesHash) {
                // Notes unchanged — reuse existing summary
                deal.notesSummary = oldSummary;
                deal.summaryHash = oldHash;
                cacheHits++;
            } else {
                dealsNeedingSummary.push(deal);
            }
        }

        // Call AI in batches to avoid timeouts
        let aiRequested = 0;
        let aiReturned = 0;
        if (dealsNeedingSummary.length > 0) {
            console.log(`${dealsNeedingSummary.length} deals need AI summaries, ${cacheHits} reusing existing (hash match).`);
            const BATCH_SIZE = 10;
            const allAiSummaries = {};

            for (let i = 0; i < dealsNeedingSummary.length; i += BATCH_SIZE) {
                const batch = dealsNeedingSummary.slice(i, i + BATCH_SIZE);
                console.log(`Processing AI batch ${Math.floor(i / BATCH_SIZE) + 1} of ${Math.ceil(dealsNeedingSummary.length / BATCH_SIZE)}...`);
                aiRequested += batch.length;
                const batchSummaries = await generateAISummaries(batch, notesMap);
                if (batchSummaries) {
                    Object.assign(allAiSummaries, batchSummaries);
                }
            }

            for (const deal of dealsNeedingSummary) {
                const allNotes = notesMap.get(deal.dealKey) || [];
                if (allAiSummaries[deal.dealKey]) {
                    deal.notesSummary = allAiSummaries[deal.dealKey];
                    aiReturned++;
                } else {
                    deal.notesSummary = generateFallbackSummary(allNotes);
                }
                deal.summaryHash = deal.notesHash;
            }
        } else {
            console.log('No notes changed, reusing all existing summaries.');
        }

        console.log(`Summary stats — AI requested: ${aiRequested}, AI returned: ${aiReturned}, cache hits: ${cacheHits}`);

        return result;
    }

    // ==================== Exports ====================
    exports.COLUMN_MAPPINGS = COLUMN_MAPPINGS;
    exports.parseCSVText = parseCSVText;
    exports.parseCSV = parseCSV;
    exports.stripHTML = stripHTML;
    exports.formatCurrency = formatCurrency;
    exports.processRow = processRow;
    exports.validateRow = validateRow;
    exports.generateFallbackSummary = generateFallbackSummary;
    exports.deduplicateDeals = deduplicateDeals;

})(typeof module !== 'undefined' && module.exports
    ? module.exports
    : (window.DealIngest = {}));
